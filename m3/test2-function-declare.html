<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
</head>
<body>
  <script>
    //선언문 방식의 함수 선언.. 가장 일반적인 형태.. 
    function add(x, y){
      return x + y
    }
    add(10, 20)

    //표현식 방식의 함수 선언(익명함수)
    let add2 = function(x, y){
      return x + y
    }
    add2(10, 20)

    //표현식 방식의 함수 선언(기명함수..)
    //기명함수도 어떤 변수에 할당될 수는 있지만.. 
    //외부에서는.. 더이상 초기 함수명으로 사용이 불가능해진다.. 그런 이름의 
    //함수가 없다고 나온다.. 대입한 변수명으로만 이용해야 한다..
    let add3 = function sum(x, y){
      return x + y
    }
    add3(10, 20)//ok.... 
    //sum(10, 20)//error - sum is not defined

    //기명함수를 변수에 할당해서 사용하는 예... .......

    //재귀함수.. 함수내에서 자신을 호출하는 함수.. 
    //알고리즘의 편의성 때문에 재귀함수를 선언하는 경우가 있다.. 
    //예를 들어서 팩토리얼을 구한는 함수가 있다고 하자.. 재귀함수를 이용해서 아래처럼
    //작성할 수 있다..
    function myFactorial(n){
      if(n==1) return 1
      return n * myFactorial(n-1)
    }
    //45!/(6!*39!)
    document.write(`로또 1등 당첨 확률은 1/${Math.round(myFactorial(45)/ myFactorial(6)/ myFactorial(39))}`)
  
    //재귀 알로리즘을 구현한 함수명에 누군가가 다른 값을 할당하는 경우가 있다.
    //재귀 알고리즘을 구현한 그 함수내부에서 myFactorial 이 계속 이용되어야 하는데
    //없음으로 에러가 발생하게 된다..
    let f = myFactorial
    // myFactorial = 10
    f(5)

    //재귀알고리즘을 이용하는 경우 함수 내부에서 사용하는 자신 함수 이름이 
    //그대로 유지되어야 함수로직이 정상적이다..
    //자신의 함수를 외부에서 다른 것으로 이용못하게.. 노출을 시키지 않는 것이 일반적이다.
    //기명함수를 다시 다른 변수에 대입해서 선언하는 이유이기도 하다..
    let myFac = function myFactorial(n){
      if(n==1) return 1
      return n * myFactorial(n-1)
    }
    myFactorial = 10
    document.write(`<p>${myFac(5)}</p>`)

  </script>
</body>
</html>